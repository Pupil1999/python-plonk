import py_ecc.bn128 as b
from polycom import *
from compiler.program import Program, CommonPreprocessedInput
from typing import Optional
from lib.curve import Scalar
from lib.utils import *
from dataclasses import dataclass
import random
import sys
from proof import Proof

@dataclass
class Prover:
    witness_len: int
    srs: SRS
    program: Program
    pk: CommonPreprocessedInput

    def __init__(self, srs: SRS, program: Program):
        self.srs = srs
        self.program = program

        # length of witness vectors a, b, c; supposed to be exponential size
        self.witness_len = program.group_order
        self.pk = program.common_preprocessed_input()
        #print(self.pk.S1.values)

    def prove(self, witness: dict[Optional[str], int]) -> Proof:
        wtl = self.witness_len
        witness.setdefault(None, 0)
        # Compute wire assignments
        A_values = [Scalar(0) for _ in range(wtl)]
        B_values = [Scalar(0) for _ in range(wtl)]
        C_values = [Scalar(0) for _ in range(wtl)]

        for i, gate_wires in enumerate(self.program.wires()):
            A_values[i] = Scalar(witness[gate_wires.L])
            B_values[i] = Scalar(witness[gate_wires.R])
            C_values[i] = Scalar(witness[gate_wires.O])   
        
        #======================= Round 1 =======================
        # The vanishing poly: x^wtl - 1
        Zh_x = Polynomial([Scalar(-1)] + [Scalar(0)]*(wtl - 1) + [Scalar(1)], Basis.MONOMIAL)

        # Random poly to achieve zero-knowledge
        b_1 = random.randint(0, sys.maxsize)
        b_2 = random.randint(0, sys.maxsize)
        b_3 = random.randint(0, sys.maxsize)
        b_4 = random.randint(0, sys.maxsize)
        b_5 = random.randint(0, sys.maxsize)
        b_6 = random.randint(0, sys.maxsize)
        b_7 = random.randint(0, sys.maxsize)
        b_8 = random.randint(0, sys.maxsize)
        b_9 = random.randint(0, sys.maxsize)

        r_a = Polynomial([Scalar(b_2), Scalar(b_1)], Basis.MONOMIAL)
        r_b = Polynomial([Scalar(b_4), Scalar(b_3)], Basis.MONOMIAL)
        r_c = Polynomial([Scalar(b_6), Scalar(b_5)], Basis.MONOMIAL)

        a_x = Polynomial(A_values, Basis.LAGRANGE).ifft() + r_a * Zh_x
        b_x = Polynomial(B_values, Basis.LAGRANGE).ifft() + r_b * Zh_x
        c_x = Polynomial(C_values, Basis.LAGRANGE).ifft() + r_c * Zh_x

        com_a = KZG.commit(self.srs, a_x)
        com_b = KZG.commit(self.srs, b_x)
        com_c = KZG.commit(self.srs, c_x)

        # Public-coin lazy generation
        self.beta = Scalar(random.randint(0, sys.maxsize))
        self.gamma = Scalar(random.randint(0, sys.maxsize))

        #======================= Round 2 =======================
        r_z = Polynomial([Scalar(b_9), Scalar(b_8), Scalar(b_7)], Basis.MONOMIAL)
        z_array = [Scalar(1)]
        roots = Scalar.roots_of_unity(wtl)
        for i in range(0, wtl - 1):
            z_array.append(
                z_array[-1]
                * self.rlc(A_values[i], roots[i])
                * self.rlc(B_values[i], 2 * roots[i]) # coset generated by 2
                * self.rlc(C_values[i], 3 * roots[i]) # coset generated by 3
                / self.rlc(A_values[i], self.pk.S1.values[i])
                / self.rlc(B_values[i], self.pk.S2.values[i])
                / self.rlc(C_values[i], self.pk.S3.values[i])
            )
        #print(z_array[-1])
        #print(z_array.__len__())

        z_x = Polynomial(z_array, Basis.LAGRANGE).ifft() + Zh_x * r_z
        com_z = KZG.commit(self.srs, z_x)

        # Public-coin lazy generation
        self.alpha = Scalar(random.randint(0, sys.maxsize))

        #======================= Round 3 =======================
        # Get public inputs
        public_vars = self.program.get_public_assignments()
        PI = Polynomial(
            [Scalar(-witness[v]) for v in public_vars]
            + [Scalar(0) for _ in range(wtl - len(public_vars))],
            Basis.LAGRANGE,
        )
        PI_x = PI.ifft()
        #print(PI.values.__len__())

        # Compute the quotient polynomial
        qM_x = self.pk.QM.ifft()
        qL_x = self.pk.QL.ifft()
        qR_x = self.pk.QR.ifft()
        qO_x = self.pk.QO.ifft()
        qC_x = self.pk.QC.ifft()
        gate_constraint_poly = (a_x * b_x * qM_x
               + a_x * qL_x
               + b_x * qR_x
               + c_x * qO_x
               + PI_x
               + qC_x)
        # Compute z(W路x)
        z_wx_coeffs = [coe*(roots[1]**(i%wtl)) for (i, coe) in enumerate(z_x.values)]
        z_wx = Polynomial(z_wx_coeffs, Basis.MONOMIAL)

        # Compute permutation check
        s1_x = self.pk.S1.ifft()
        s2_x = self.pk.S2.ifft()
        s3_x = self.pk.S3.ifft()
        permutation_poly = (a_x + self.to_lpoly(1)) * (
                            b_x + self.to_lpoly(2)) * (
                            c_x + self.to_lpoly(3)) * z_x - (
                            a_x + self.get_sdx_lc(s1_x)) * (
                            b_x + self.get_sdx_lc(s2_x)) * (
                            c_x + self.get_sdx_lc(s3_x)) * z_wx
        #print("The eval is {}".format(permutation_poly.coeff_eval(roots[7])))

        l1_x = Polynomial([Scalar(1)] + [Scalar(0)] * (wtl - 1), Basis.LAGRANGE).ifft()
        permu_firstelm_poly = (z_x - Scalar(1)) * l1_x

        t_x = (gate_constraint_poly
             + permutation_poly * Scalar(self.alpha)
             + permu_firstelm_poly * Scalar(self.alpha**2)) / Zh_x
        
        t_low, t_mid, t_hi = self.split_tx(t_x, wtl)
        #print(t_hi.values.__len__())
        com_t_low = KZG.commit(self.srs, t_low)
        com_t_mid = KZG.commit(self.srs, t_mid)
        com_t_hi = KZG.commit(self.srs, t_hi)
        
        self.zeta = Scalar(random.randint(0, sys.maxsize))
        #self.zeta = roots[6]

        #======================= Round 4 =======================
        a_zeta = a_x.coeff_eval(self.zeta)
        b_zeta = b_x.coeff_eval(self.zeta)
        c_zeta = c_x.coeff_eval(self.zeta)
        s1_zeta = s1_x.coeff_eval(self.zeta)
        s2_zeta = s2_x.coeff_eval(self.zeta)
        z_wzeta = z_x.coeff_eval(self.zeta * roots[1])

        self.v = Scalar(random.randint(0, sys.maxsize))
        
        #======================= Round 5 =======================
        PI_zeta = PI_x.coeff_eval(self.zeta)

        gate_mid_x = (qM_x*b_zeta + qL_x)*a_zeta + qR_x*b_zeta + qO_x*c_zeta + PI_zeta + qC_x 

        # The following two hasn't been combined with self.alpha
        perm_mid_up_x = (z_x*(a_zeta + self.beta*self.zeta + self.gamma)*(b_zeta + self.beta*Scalar(2)*self.zeta + self.gamma)*(c_zeta + self.beta*Scalar(3)*self.zeta + self.gamma))

        perm_mid_down_x = (s3_x*self.beta + c_zeta + self.gamma)*(a_zeta + self.beta*s1_zeta + self.gamma)*(b_zeta + self.beta*s2_zeta + self.gamma)*z_wzeta

        # This part is public
        l1_mid_x = (z_x - Scalar(1))*l1_x.coeff_eval(self.zeta)

        equ_right_x = (t_low + t_mid*(self.zeta**wtl) + t_hi*(self.zeta**(2*wtl)))*Zh_x.coeff_eval(self.zeta)

        r_x = gate_mid_x + (perm_mid_up_x - perm_mid_down_x)*self.alpha + l1_mid_x * (self.alpha**2) - equ_right_x

        # Should always output 0 on self.zeta
        #print(r_x.coeff_eval(self.zeta))

        w_x = (r_x + (a_x-a_zeta)*self.v + (b_x-b_zeta)*(self.v**2) + (c_x-c_zeta)*(self.v**3) + (s1_x-s1_zeta)*(self.v**4) + (s2_x-s2_zeta)*(self.v**5))/(
            Polynomial([-self.zeta, Scalar(1)], Basis.MONOMIAL)
        )

        # Should always output 0 if w_x hasn't been divided by x - self.zeta
        #print(w_x.coeff_eval(self.zeta))
        #print(w_x.values)

        com_w_x = KZG.commit(self.srs, w_x)

        #print(z_x.coeff_eval(Scalar(roots[1]) * Scalar(self.zeta)), z_wzeta)
        w_zx = (z_x - z_wzeta) / (Polynomial([-roots[1] * self.zeta, Scalar(1)], Basis.MONOMIAL))
        com_w_zx = KZG.commit(self.srs, w_zx)

        # Public-coin lazy generation
        self.u = Scalar(random.randint(0, sys.maxsize))
        
        return Proof(
            [com_a, com_b, com_c],
            [com_z],
            [com_t_low, com_t_mid, com_t_hi],
            [a_zeta, b_zeta, c_zeta, s1_zeta, s2_zeta, z_wzeta],
            [com_w_x, com_w_zx],
            [self.beta, self.gamma, self.alpha, self.zeta, self.v, self.u]
        )

    def rlc(self, term_1, term_2):
        return term_1 + term_2 * self.beta + self.gamma
    
    # to linear poly
    # Get poly p(x) = self.gamma + (self.beta * k)x
    def to_lpoly(self, k):
        return Polynomial([Scalar(self.gamma), Scalar(self.beta) * Scalar(k)], Basis.MONOMIAL)
    
    def get_sdx_lc(self, sdx: Polynomial):
        return sdx * Scalar(self.beta) + Scalar(self.gamma)
    
    # Split t_x = t_hi路x^(2路wtl) + t_mid路x^(wtl) + t_low
    def split_tx(self, tx: Polynomial, wtl):
        assert(tx.values.__len__() >= 2 * wtl)
        t_low = Polynomial(tx.values[:wtl], Basis.MONOMIAL)
        t_mid = Polynomial(tx.values[wtl:2*wtl], Basis.MONOMIAL)
        t_hi = Polynomial(tx.values[2*wtl:], Basis.MONOMIAL)
        return t_low, t_mid, t_hi